{
  "contract_name": "mars-incentives",
  "contract_version": "2.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "address_provider",
      "epoch_duration",
      "max_whitelisted_denoms",
      "owner"
    ],
    "properties": {
      "address_provider": {
        "description": "Address provider",
        "type": "string"
      },
      "epoch_duration": {
        "description": "The amount of time in seconds for each incentive epoch. This is the minimum amount of time that an incentive can last, and each incentive must be a multiple of this duration.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "max_whitelisted_denoms": {
        "description": "The maximum number of incentive denoms that can be whitelisted at any given time. This is a guard against accidentally whitelisting too many denoms, which could cause max gas errors.",
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "owner": {
        "description": "Contract owner",
        "type": "string"
      }
    },
    "additionalProperties": false
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Add or remove incentive denoms from the whitelist. Only admin can do this.",
        "type": "object",
        "required": [
          "update_whitelist"
        ],
        "properties": {
          "update_whitelist": {
            "type": "object",
            "required": [
              "add_denoms",
              "remove_denoms"
            ],
            "properties": {
              "add_denoms": {
                "description": "The denoms to add to the whitelist as well as a minimum emission rate per second for each. If the denom is already in the whitelist, the minimum emission rate will be updated.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/WhitelistEntry"
                }
              },
              "remove_denoms": {
                "description": "The denoms to remove from the whitelist. This will update the index of the incentive state and then remove any active incentive schedules.\n\nNB: If any incentive schedules are still active for this incentive denom, the incentive tokens will be trapped forever in the contract.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add incentives for a given collateral denom and incentive denom pair",
        "type": "object",
        "required": [
          "set_asset_incentive"
        ],
        "properties": {
          "set_asset_incentive": {
            "type": "object",
            "required": [
              "collateral_denom",
              "duration",
              "emission_per_second",
              "incentive_denom",
              "start_time"
            ],
            "properties": {
              "collateral_denom": {
                "description": "The denom of the collatearal token to receive incentives",
                "type": "string"
              },
              "duration": {
                "description": "How many seconds the incentives last",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "emission_per_second": {
                "description": "How many `incentive_denom` tokens will be assigned per second to be distributed among all Red Bank depositors",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "incentive_denom": {
                "description": "The denom of the token to give incentives with",
                "type": "string"
              },
              "start_time": {
                "description": "Start time of the incentive (in seconds) since the UNIX epoch (00:00:00 on 1970-01-01 UTC).",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Handle balance change updating user and asset rewards. Sent from an external contract, triggered on user balance changes. Will return an empty response if no incentive is applied for the asset",
        "type": "object",
        "required": [
          "balance_change"
        ],
        "properties": {
          "balance_change": {
            "type": "object",
            "required": [
              "denom",
              "total_amount_scaled_before",
              "user_addr",
              "user_amount_scaled_before"
            ],
            "properties": {
              "account_id": {
                "description": "Credit account id (Rover)",
                "type": [
                  "string",
                  "null"
                ]
              },
              "denom": {
                "description": "Denom of the asset of which deposited balance is changed",
                "type": "string"
              },
              "total_amount_scaled_before": {
                "description": "The market's total scaled collateral amount up to the instant before the change",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "user_addr": {
                "description": "User address. Address is trusted as it must be validated by the Red Bank contract before calling this method",
                "allOf": [
                  {
                    "$ref": "#/definitions/Addr"
                  }
                ]
              },
              "user_amount_scaled_before": {
                "description": "The user's scaled collateral amount up to the instant before the change",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claim rewards. MARS rewards accrued by the user will be staked into xMARS before being sent.",
        "type": "object",
        "required": [
          "claim_rewards"
        ],
        "properties": {
          "claim_rewards": {
            "type": "object",
            "properties": {
              "account_id": {
                "description": "Credit account id (Rover)",
                "type": [
                  "string",
                  "null"
                ]
              },
              "limit": {
                "description": "The maximum number of results to return. If not set, 5 is used. If larger than 10, 10 is used.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after_collateral_denom": {
                "description": "Start pagination after this collateral denom",
                "type": [
                  "string",
                  "null"
                ]
              },
              "start_after_incentive_denom": {
                "description": "Start pagination after this incentive denom. If supplied you must also supply start_after_collateral_denom.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "claim_staked_astro_lp_rewards"
        ],
        "properties": {
          "claim_staked_astro_lp_rewards": {
            "type": "object",
            "required": [
              "account_id",
              "lp_denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "lp_denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Stake Astroport LP tokens in astroport incentives contract to receive rewards.",
        "type": "object",
        "required": [
          "stake_astro_lp"
        ],
        "properties": {
          "stake_astro_lp": {
            "type": "object",
            "required": [
              "account_id",
              "lp_coin"
            ],
            "properties": {
              "account_id": {
                "description": "User credit account Id",
                "type": "string"
              },
              "lp_coin": {
                "description": "AstroLp token to stake.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Coin"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unstake Astroport LP tokens from astroport incentives contract. Sends tokens back to the users credit account",
        "type": "object",
        "required": [
          "unstake_astro_lp"
        ],
        "properties": {
          "unstake_astro_lp": {
            "type": "object",
            "required": [
              "account_id",
              "lp_coin"
            ],
            "properties": {
              "account_id": {
                "description": "User credit account Id",
                "type": "string"
              },
              "lp_coin": {
                "description": "AstroLp token to unstake.",
                "allOf": [
                  {
                    "$ref": "#/definitions/ActionCoin"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update contract config (only callable by owner)",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "address_provider": {
                "description": "The address provider contract address",
                "type": [
                  "string",
                  "null"
                ]
              },
              "max_whitelisted_denoms": {
                "description": "The maximum number of incentive denoms that can be whitelisted at any given time. This is a guard against accidentally whitelisting too many denoms, which could cause max gas errors.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Manages admin role state",
        "type": "object",
        "required": [
          "update_owner"
        ],
        "properties": {
          "update_owner": {
            "$ref": "#/definitions/OwnerUpdate"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "migrate"
        ],
        "properties": {
          "migrate": {
            "$ref": "#/definitions/MigrateV1ToV2"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ActionAmount": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "account_balance"
            ]
          },
          {
            "type": "object",
            "required": [
              "exact"
            ],
            "properties": {
              "exact": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ActionCoin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/ActionAmount"
          },
          "denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "MigrateV1ToV2": {
        "description": "Migrate from V1 to V2, only owner can call",
        "oneOf": [
          {
            "description": "Migrate users indexes and unclaimed rewards in batches",
            "type": "object",
            "required": [
              "users_indexes_and_rewards"
            ],
            "properties": {
              "users_indexes_and_rewards": {
                "type": "object",
                "required": [
                  "limit"
                ],
                "properties": {
                  "limit": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears old V1 state once all batches are migrated or after a certain time",
            "type": "object",
            "required": [
              "clear_v1_state"
            ],
            "properties": {
              "clear_v1_state": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "OwnerUpdate": {
        "oneOf": [
          {
            "description": "Proposes a new owner to take role. Only current owner can execute.",
            "type": "object",
            "required": [
              "propose_new_owner"
            ],
            "properties": {
              "propose_new_owner": {
                "type": "object",
                "required": [
                  "proposed"
                ],
                "properties": {
                  "proposed": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the currently proposed owner. Only current owner can execute.",
            "type": "string",
            "enum": [
              "clear_proposed"
            ]
          },
          {
            "description": "Promotes the proposed owner to be the current one. Only the proposed owner can execute.",
            "type": "string",
            "enum": [
              "accept_proposed"
            ]
          },
          {
            "description": "Throws away the keys to the Owner role forever. Once done, no owner can ever be set later.",
            "type": "string",
            "enum": [
              "abolish_owner_role"
            ]
          },
          {
            "description": "A separate entity managed by Owner that can be used for granting specific emergency powers.",
            "type": "object",
            "required": [
              "set_emergency_owner"
            ],
            "properties": {
              "set_emergency_owner": {
                "type": "object",
                "required": [
                  "emergency_owner"
                ],
                "properties": {
                  "emergency_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove the entity in the Emergency Owner role",
            "type": "string",
            "enum": [
              "clear_emergency_owner"
            ]
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "WhitelistEntry": {
        "type": "object",
        "required": [
          "denom",
          "min_emission_rate"
        ],
        "properties": {
          "denom": {
            "description": "The incentive token denom that is whitelisted",
            "type": "string"
          },
          "min_emission_rate": {
            "description": "The minimum emission rate per second for this incentive token",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Query account staked LP rewards",
        "type": "object",
        "required": [
          "staked_astro_lp_rewards"
        ],
        "properties": {
          "staked_astro_lp_rewards": {
            "type": "object",
            "required": [
              "account_id",
              "lp_denom"
            ],
            "properties": {
              "account_id": {
                "description": "The id of the account who owns the LP",
                "type": "string"
              },
              "lp_denom": {
                "description": "Denom of LP that is accruing rewards",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query all active incentive emissions for a collateral denom",
        "type": "object",
        "required": [
          "active_emissions"
        ],
        "properties": {
          "active_emissions": {
            "type": "object",
            "required": [
              "collateral_denom"
            ],
            "properties": {
              "collateral_denom": {
                "description": "The denom of the token that users supply as collateral to receive incentives",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query contract config",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query info about the state of an incentive for a given collateral and incentive denom pair",
        "type": "object",
        "required": [
          "incentive_state"
        ],
        "properties": {
          "incentive_state": {
            "type": "object",
            "required": [
              "collateral_denom",
              "incentive_denom"
            ],
            "properties": {
              "collateral_denom": {
                "description": "The denom of the token that users supply as collateral to receive incentives",
                "type": "string"
              },
              "incentive_denom": {
                "description": "The denom of the token which is used to give incentives with",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate incentive states with pagination",
        "type": "object",
        "required": [
          "incentive_states"
        ],
        "properties": {
          "incentive_states": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "The maximum number of results to return. If not set, 5 is used. If larger than 10, 10 is used.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after_collateral_denom": {
                "description": "Start pagination after this collateral denom",
                "type": [
                  "string",
                  "null"
                ]
              },
              "start_after_incentive_denom": {
                "description": "Start pagination after this incentive denom. If supplied you must also supply start_after_collateral_denom.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Queries the planned emission rate for a given collateral and incentive denom tuple at the specified unix timestamp. The emission rate returned is the amount of incentive tokens that will be emitted per second for each unit of collateral supplied during the epoch. NB: that the returned value can change if someone adds incentives to the contract.",
        "type": "object",
        "required": [
          "emission"
        ],
        "properties": {
          "emission": {
            "type": "object",
            "required": [
              "collateral_denom",
              "incentive_denom",
              "timestamp"
            ],
            "properties": {
              "collateral_denom": {
                "description": "The denom of the token that users supply as collateral to receive incentives",
                "type": "string"
              },
              "incentive_denom": {
                "description": "The denom of the token which is used to give incentives with",
                "type": "string"
              },
              "timestamp": {
                "description": "The unix timestamp in second to query the emission rate at.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate all incentive emission rates with pagination for a specified collateral and indentive denom pair",
        "type": "object",
        "required": [
          "emissions"
        ],
        "properties": {
          "emissions": {
            "type": "object",
            "required": [
              "collateral_denom",
              "incentive_denom"
            ],
            "properties": {
              "collateral_denom": {
                "description": "The denom of the token that users supply as collateral to receive incentives",
                "type": "string"
              },
              "incentive_denom": {
                "description": "The denom of the token which is used to give incentives with",
                "type": "string"
              },
              "limit": {
                "description": "The maximum number of results to return. If not set, 5 is used. If larger than 10, 10 is used.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after_timestamp": {
                "description": "Start pagination after this timestamp",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate a users LP positions with pagination",
        "type": "object",
        "required": [
          "staked_astro_lp_positions"
        ],
        "properties": {
          "staked_astro_lp_positions": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "description": "The id of the account who owns the LP",
                "type": "string"
              },
              "limit": {
                "description": "The maximum number of results to return. If not set, 5 is used. If larger than 10, 10 is used.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Start pagination after this lp denom, if used.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get specific details on a users LP Position",
        "type": "object",
        "required": [
          "staked_astro_lp_position"
        ],
        "properties": {
          "staked_astro_lp_position": {
            "type": "object",
            "required": [
              "account_id",
              "lp_denom"
            ],
            "properties": {
              "account_id": {
                "description": "The id of the account who owns the LP",
                "type": "string"
              },
              "lp_denom": {
                "description": "The denom of the LP position",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query user current unclaimed rewards",
        "type": "object",
        "required": [
          "user_unclaimed_rewards"
        ],
        "properties": {
          "user_unclaimed_rewards": {
            "type": "object",
            "required": [
              "user"
            ],
            "properties": {
              "account_id": {
                "description": "Credit account id (Rover)",
                "type": [
                  "string",
                  "null"
                ]
              },
              "limit": {
                "description": "The maximum number of results to return. If not set, 5 is used. If larger than 10, 10 is used.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after_collateral_denom": {
                "description": "Start pagination after this collateral denom",
                "type": [
                  "string",
                  "null"
                ]
              },
              "start_after_incentive_denom": {
                "description": "Start pagination after this incentive denom. If supplied you must also supply start_after_collateral_denom.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "user": {
                "description": "The user address for which to query unclaimed rewards",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Queries the incentive denom whitelist. Returns a Vec<(String, Uint128)> containing the denoms of all whitelisted incentive denoms, as well as the minimum emission rate for each.",
        "type": "object",
        "required": [
          "whitelist"
        ],
        "properties": {
          "whitelist": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "active_emissions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ActiveEmission",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ActiveEmission"
      },
      "definitions": {
        "ActiveEmission": {
          "description": "The currently active emission for a given incentive denom",
          "type": "object",
          "required": [
            "denom",
            "emission_rate"
          ],
          "properties": {
            "denom": {
              "description": "The denom for which incentives are being distributed",
              "type": "string"
            },
            "emission_rate": {
              "description": "The amount of incentive tokens that are being emitted per second",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ConfigResponse",
      "type": "object",
      "required": [
        "address_provider",
        "epoch_duration",
        "max_whitelisted_denoms",
        "whitelist_count"
      ],
      "properties": {
        "address_provider": {
          "description": "Address provider",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "epoch_duration": {
          "description": "The epoch duration in seconds",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "max_whitelisted_denoms": {
          "description": "The maximum number of incentive denoms that can be whitelisted at any given time. This is a guard against accidentally whitelisting too many denoms, which could cause max gas errors.",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "owner": {
          "description": "The contract's owner",
          "type": [
            "string",
            "null"
          ]
        },
        "proposed_new_owner": {
          "description": "The contract's proposed owner",
          "type": [
            "string",
            "null"
          ]
        },
        "whitelist_count": {
          "description": "The count of the number of whitelisted incentive denoms",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "emission": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "emissions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_EmissionResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/EmissionResponse"
      },
      "definitions": {
        "EmissionResponse": {
          "type": "object",
          "required": [
            "emission_rate",
            "epoch_start"
          ],
          "properties": {
            "emission_rate": {
              "description": "The emission rate returned is the amount of incentive tokens that will be emitted per second for each unit of collateral supplied during the epoch.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "epoch_start": {
              "description": "The unix timestamp in seconds at which the emission epoch starts",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "incentive_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IncentiveStateResponse",
      "description": "Incentive Metadata for a given incentive denom",
      "type": "object",
      "required": [
        "collateral_denom",
        "incentive_denom",
        "index",
        "last_updated"
      ],
      "properties": {
        "collateral_denom": {
          "description": "The denom for which users get the incentive if they provide collateral in the Red Bank",
          "type": "string"
        },
        "incentive_denom": {
          "description": "The denom of the token these incentives are paid with",
          "type": "string"
        },
        "index": {
          "description": "An index that represents how many incentive tokens have been distributed per unit of collateral",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "last_updated": {
          "description": "Last time (in seconds) index was updated",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "incentive_states": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_IncentiveStateResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/IncentiveStateResponse"
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IncentiveStateResponse": {
          "description": "Incentive Metadata for a given incentive denom",
          "type": "object",
          "required": [
            "collateral_denom",
            "incentive_denom",
            "index",
            "last_updated"
          ],
          "properties": {
            "collateral_denom": {
              "description": "The denom for which users get the incentive if they provide collateral in the Red Bank",
              "type": "string"
            },
            "incentive_denom": {
              "description": "The denom of the token these incentives are paid with",
              "type": "string"
            },
            "index": {
              "description": "An index that represents how many incentive tokens have been distributed per unit of collateral",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_updated": {
              "description": "Last time (in seconds) index was updated",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "staked_astro_lp_position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakedLpPositionResponse",
      "type": "object",
      "required": [
        "lp_coin",
        "rewards"
      ],
      "properties": {
        "lp_coin": {
          "$ref": "#/definitions/Coin"
        },
        "rewards": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "staked_astro_lp_positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PaginationResponse_for_StakedLpPositionResponse",
      "type": "object",
      "required": [
        "data",
        "metadata"
      ],
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/StakedLpPositionResponse"
          }
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Metadata": {
          "type": "object",
          "required": [
            "has_more"
          ],
          "properties": {
            "has_more": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "StakedLpPositionResponse": {
          "type": "object",
          "required": [
            "lp_coin",
            "rewards"
          ],
          "properties": {
            "lp_coin": {
              "$ref": "#/definitions/Coin"
            },
            "rewards": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Coin"
              }
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "staked_astro_lp_rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PaginationResponse_for_Tuple_of_String_and_Array_of_Coin",
      "type": "object",
      "required": [
        "data",
        "metadata"
      ],
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Coin"
                }
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Metadata": {
          "type": "object",
          "required": [
            "has_more"
          ],
          "properties": {
            "has_more": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "user_unclaimed_rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Coin",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Coin"
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "whitelist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_WhitelistEntry",
      "type": "array",
      "items": {
        "$ref": "#/definitions/WhitelistEntry"
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "WhitelistEntry": {
          "type": "object",
          "required": [
            "denom",
            "min_emission_rate"
          ],
          "properties": {
            "denom": {
              "description": "The incentive token denom that is whitelisted",
              "type": "string"
            },
            "min_emission_rate": {
              "description": "The minimum emission rate per second for this incentive token",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
